# 최종 명확화 질문 및 답변

## 세 번째 질문 세트 (데이터 매핑 및 구현 세부사항)

### Q19: 데이터 매핑 정의 - ScenarioComposer 핵심 로직
**A19**: 메타데이터랑 바인딩 yaml의 예제를 전달했는데, 꼭 그 예제를 사용해야되는건 아님. 그런 식의 개념을 이번 구현에 사용하거나 하는 것. 최종적으로 여러 과정을 거쳐서 저 json파일들을 생성해서 시뮬레이터의 인풋으로 전달해야함

**해석**: 
- MetaData.json과 bindings.yaml은 개념적 참고용
- 실제 구현에서는 유연하게 적용
- 핵심은 NSGA가 요구하는 6개 JSON 파일을 생성하는 것
- 구체적인 변환 로직은 구현자가 설계

### Q20: 데이터 소스 전략 결정
**A20**: 최대한 기존 AAS 데이터 활용을 위해 정적인 파일들은 그대로 AAS 서버에 업로드하여 사용하려고 함. 우선은 A) 방식으로.

**해석**:
- PRD의 하이브리드 전략 채택
- 정적 시나리오 파일들 → AAS Scenario_* Submodel에 JSON 문자열로 저장
- 동적 데이터 (machines.json) → 실시간 AAS 조회로 생성
- bindings.yaml의 file:// 방식은 당분간 미적용

### Q21: @현재시간 매크로 처리
**A21**: 요청이 들어올때 전처리하면서 치환함. ISO 8601 로

**해석**:
- ScenarioComposer에서 QueryGoal 처리 시 @현재시간을 실제 timestamp로 치환
- 형식: ISO 8601 (예: "2025-09-16T15:30:00Z")
- 전처리 단계에서 수행

### Q22: NSGA 출력 형식
**A22**: 음..이건 직접 실행, 테스트해봐야할듯

**해석**:
- NSGA 시뮬레이터 실행 후 출력 형식 분석 필요
- simulator_optimization_result.json → QueryGoal outputSpec 변환 로직은 테스트 후 결정
- 대기 상태: NSGA 시뮬레이터 실행 방법 확인 후 진행

### Q23: Container 이미지 전략
**A23**: ㅇㅇ A 아니면 B 일듯

**해석**:
- 옵션 A: NSGA 시뮬레이터를 직접 Docker화
- 옵션 B: NSGA + 래퍼 스크립트를 함께 Docker화
- 최종 결정은 NSGA 의존성 확인 후

### Q24: 파일 경로 및 K8s 설정
**A24**: 이건 음... binding yaml파일에서 파일 시스템을 매칭할때 필요한 거라서 하이브리드 형식, AAS 서버에서 json 파일을 통째로 가져오는 식이라면 필요없을지도

**해석**:
- AAS Submodel 방식을 사용하므로 파일 시스템 매핑 불필요
- PVC 경로는 NSGA 시뮬레이터 입력/출력 파일용으로만 사용
- bindings.yaml의 file:// 설정은 현재 구현에서 제외

## 구현 방향 정리

### ✅ 확정된 사항
1. **데이터 전략**: AAS Scenario_* Submodel 방식 (PRD 하이브리드 전략)
2. **시간 처리**: @현재시간 → ISO 8601 치환
3. **컨테이너**: NSGA 시뮬레이터 Docker화 (A 또는 B 옵션)
4. **구현 유연성**: MetaData/bindings 예제는 참고용, 실제 로직은 자유롭게 설계

### ⏳ 대기 중인 사항
1. **NSGA 실행 방법**: 담당자 확인 중
2. **Docker 의존성**: 담당자 확인 중 또는 이미지 제공
3. **AAS 데이터 준비**: M1-M4 명명 + Scenario_* Submodel 추가
4. **NSGA 출력 분석**: 실제 테스트 필요

### 🎯 구현 시작 가능한 부분
1. **API 스키마 업데이트**: QueryGoal Pydantic 모델
2. **ScenarioComposer 기본 구조**: @현재시간 치환, AAS 조회 로직
3. **ExecutionAgent 리팩토링**: 시나리오 경로 기반 K8s Job 실행
4. **기본 테스트 프레임워크**: 목업 데이터 활용

## 다음 단계
1. AAS 서버 데이터 업데이트 완료 대기
2. NSGA 시뮬레이터 실행 정보 확인 대기
3. 위 두 가지 준비되는 대로 구현 시작